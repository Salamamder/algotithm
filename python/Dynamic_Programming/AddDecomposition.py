# 합분해까지
# 가장 긴 증가하는 부분 수열
# 각각의 수 마다 앞에나온 수들을 다 하나씩 훑허보는 모양이라
# 시간복잡도는 n^2이 된다. 

# 아래는 예시 문제 해보기
arr = [10, 20, 10, 30, 20, 50]
n = 6
# ------------------------------------

def AD(arr, n):
    n = n + 1
    arr.insert(0,0)
    dp = [0] * (n) # 다른곳에서는 n+5를 사용하는데 왜인지는 일단 모르고 나중에 확인 해야함
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[j]+1, dp[i])
    return dp

print(AD(arr, n))

# ----------------------------------------------------------------------------------------
# 생각해보면 0을 추가할 필요가 없음
# 모든 길이는 1부터 시작이기도 함
# 그걸 문제에 적용해서 풀어보면
# arr = [10, 20, 10, 30, 20, 50]
# n = 6
# # ------------------------------------

# def AD(arr, n):
#     arr.insert(0,0)
#     dp = [1] * (n) # 다른곳에서는 n+5를 사용하는데 왜인지는 일단 모르고 나중에 확인 해야함
#     for i in range(1, n):
#         for j in range(i):
#             if arr[i] > arr[j]:
#                 dp[i] = max(dp[j]+1, dp[i])
#     return dp

# print(AD(arr, n))
# 위의 방식으로 하면 문제가 발생 길이가 짧아도 뭔가 숫자가 더해지면서 값이 이상하게 나옴 즉 [0]을 넣어서 문제를 풀어야 함
# --------------------------------------------------------------------------------------------------------------


# 연속합문제 Continuous Sum
def CS(arr):
    n = len(arr)
    dp = arr
    for i in range(1, n):
        dp[i] = max(arr[i], arr[i]+dp[i-1])
    return max(dp)
arr = [2, 1, -4, 3, 4, -4, 6, 5, -5, 1]
print(CS(arr))
# ------------------------------------------------------------

# 제곱수의 합
# 123더하기 문제와 유사
